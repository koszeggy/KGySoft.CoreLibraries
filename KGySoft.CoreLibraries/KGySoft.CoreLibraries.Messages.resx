<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="General_ArgumentNull" xml:space="preserve">
    <value>Value cannot be null.</value>
  </data>
  <data name="General_ArgumentContainsNull" xml:space="preserve">
    <value>Specified argument contains a null element.</value>
  </data>
  <data name="General_ArgumentOutOfRange" xml:space="preserve">
    <value>Specified argument was out of the range of valid values.</value>
  </data>
  <data name="General_IndexOutOfRange" xml:space="preserve">
    <value>Index was outside the bounds of the array.</value>
  </data>
  <data name="General_ArgumentMustBeGreaterThanFormat" xml:space="preserve">
    <value>Specified argument must be greater than {0}.</value>
  </data>
  <data name="General_ArgumentMustBeGreaterThanOrEqualToFormat" xml:space="preserve">
    <value>Specified argument must be greater than or equal to {0}.</value>
  </data>
  <data name="General_ArgumentMustBeLessThanFormat" xml:space="preserve">
    <value>Specified argument must be less than {0}.</value>
  </data>
  <data name="General_ArgumentMustBeLessThanOrEqualToFormat" xml:space="preserve">
    <value>Specified argument must be less than or equal to {0}.</value>
  </data>
  <data name="General_ArgumentMustBeBetweenFormat" xml:space="preserve">
    <value>Specified argument must be between {0} and {1}.</value>
  </data>
  <data name="General_MaxValueLessThanMinValue" xml:space="preserve">
    <value>Maximum value must be greater than or equal to minimum value.</value>
  </data>
  <data name="General_MaxLengthLessThanMinLength" xml:space="preserve">
    <value>Maximum length must be greater than or equal to minimum length.</value>
  </data>
  <data name="General_PropertyNullFormat" xml:space="preserve">
    <value>Property '{0}' must not be null.</value>
  </data>
  <data name="General_PropertyMustBeGreaterThanFormat" xml:space="preserve">
    <value>Property '{0}' must be greater than {1}.</value>
  </data>
  <data name="General_PropertyMustBeGreaterThanOrEqualToFormat" xml:space="preserve">
    <value>Property '{0}' must be greater than or equal to {1}.</value>
  </data>
  <data name="General_PropertyMustBeLessThanFormat" xml:space="preserve">
    <value>Property '{0}' must be less than {1}.</value>
  </data>
  <data name="General_PropertyMustBeLessThanOrEqualToFormat" xml:space="preserve">
    <value>Property '{0}' must be less than or equal to {1}.</value>
  </data>
  <data name="General_PropertyMustBeBetweenFormat" xml:space="preserve">
    <value>Property '{0}' must be between {1} and {2}.</value>
  </data>
  <data name="General_PropertyMustBeGreaterThanPropertyFormat" xml:space="preserve">
    <value>Property '{0}' must be greater than property '{1}'.</value>
  </data>
  <data name="General_PropertyMustBeGreaterThanOrEqualToPropertyFormat" xml:space="preserve">
    <value>Property '{0}' must be greater than or equal to property '{1}'.</value>
  </data>
  <data name="General_PropertyMessageFormat" xml:space="preserve">
    <value>Property '{0}': {1}</value>
  </data>
  <data name="General_Yes" xml:space="preserve">
    <value>Yes</value>
  </data>
  <data name="General_No" xml:space="preserve">
    <value>No</value>
  </data>
  <data name="General_Millisecond" xml:space="preserve">
    <value>ms</value>
  </data>
  <data name="FastRandom_ZeroSeeds" xml:space="preserve">
    <value>At least one of the seeds must be nonzero.</value>
  </data>
  <data name="PerformanceTest_NoTestCases" xml:space="preserve">
    <value>No test cases are added.</value>
  </data>
  <data name="PerformanceTest_Item" xml:space="preserve">
    <value>item</value>
  </data>
  <data name="PerformanceTest_Byte" xml:space="preserve">
    <value>byte</value>
  </data>
  <data name="PerformanceTest_NoDifference" xml:space="preserve">
    <value> No difference</value>
  </data>
  <data name="PerformanceTest_DefaultName" xml:space="preserve">
    <value>Performance Test</value>
  </data>
  <data name="PerformanceTest_SortBySize" xml:space="preserve">
    <value>size (shortest first)</value>
  </data>
  <data name="PerformanceTest_SortByTime" xml:space="preserve">
    <value>time (quickest first)</value>
  </data>
  <data name="PerformanceTest_SortByIterations" xml:space="preserve">
    <value>fulfilled iterations (the most first)</value>
  </data>
  <data name="PerformanceTest_Separator" xml:space="preserve">
    <value>--------------------------------------------------</value>
  </data>
  <data name="PerformanceTest_BestMark" xml:space="preserve">
    <value>&#x9; &lt;---- Best</value>
  </data>
  <data name="PerformanceTest_WorstMark" xml:space="preserve">
    <value>&#x9; &lt;---- Worst</value>
  </data>
  <data name="PerformanceTest_WorstBestDiff" xml:space="preserve">
    <value>  Worst-Best difference: </value>
  </data>
  <data name="PerformanceTest_DumpedResult" xml:space="preserve">
    <value>Dumped result:</value>
  </data>
  <data name="PerformanceTest_DumpedError" xml:space="preserve">
    <value>Error dump:</value>
  </data>
  <data name="PerformanceTest_CaseDefaultNameFormat" xml:space="preserve">
    <value>Case #{0}</value>
  </data>
  <data name="PerformanceTest_CaseNameFormat" xml:space="preserve">
    <value>{0}: </value>
  </data>
  <data name="PerformanceTest_HeaderFormat" xml:space="preserve">
    <value>==[{0} Results]================================================</value>
  </data>
  <data name="PerformanceTest_IterationsFormat" xml:space="preserve">
    <value>Iterations: {0:N0}</value>
  </data>
  <data name="PerformanceTest_TestTimeFormat" xml:space="preserve">
    <value>Test Time: {0:N0} ms</value>
  </data>
  <data name="PerformanceTest_WarmingUpFormat" xml:space="preserve">
    <value>Warming up: {0}</value>
  </data>
  <data name="PerformanceTest_TestCasesFormat" xml:space="preserve">
    <value>Test cases: {0}</value>
  </data>
  <data name="PerformanceTest_RepeatsFormat" xml:space="preserve">
    <value>Repeats: {0}</value>
  </data>
  <data name="PerformanceTest_CallingGcCollectFormat" xml:space="preserve">
    <value>Calling GC.Collect: {0}</value>
  </data>
  <data name="PerformanceTest_CpuAffinityFormat" xml:space="preserve">
    <value>Forced CPU Affinity: {0}</value>
  </data>
  <data name="PerformanceTest_SortOfCasesFormat" xml:space="preserve">
    <value>Cases are sorted by {0}</value>
  </data>
  <data name="PerformanceTest_CaseAverageTimeFormat" xml:space="preserve">
    <value>average time: {0:N2} ms</value>
  </data>
  <data name="PerformanceTest_CaseOrderFormat" xml:space="preserve">
    <value>{0}. </value>
  </data>
  <data name="PerformanceTest_DifferenceFormat" xml:space="preserve">
    <value> ({0}{1:N2}{2} / {3:P2})</value>
  </data>
  <data name="PerformanceTest_CaseIterationsFormat" xml:space="preserve">
    <value>{0:N0} iterations in {1:N2} ms. Adjusted for {2:N0} ms: {3:N2}</value>
  </data>
  <data name="PerformanceTest_CaseRepetitionOrderFormat" xml:space="preserve">
    <value>  #{0,-2} {1}</value>
  </data>
  <data name="PerformanceTest_CaseRepetitionTimeFormat" xml:space="preserve">
    <value>{0,13:N2} ms</value>
  </data>
  <data name="PerformanceTest_CaseRepetitionIterationsFormat" xml:space="preserve">
    <value>{0:N0} iterations in {1:N2} ms. Adjusted: {2:N2}</value>
  </data>
  <data name="PerformanceTest_CaseErrorFormat" xml:space="preserve">
    <value>{0}: {1}</value>
  </data>
  <data name="PerformanceTest_WorstBestDiffTimeFormat" xml:space="preserve">
    <value>{0:N2} ms ({1:P2})</value>
  </data>
  <data name="PerformanceTest_WorstBestDiffIterationFormat" xml:space="preserve">
    <value>{0:N2} ({1:P2})</value>
  </data>
  <data name="PerformanceTest_ResultSizeFormat" xml:space="preserve">
    <value>  Result size: {0:N0} {1}</value>
  </data>
  <data name="PerformanceTest_UnitPossiblePluralFormat" xml:space="preserve">
    <value>{0}(s)</value>
  </data>
  <data name="ICollection_CopyToSingleDimArrayOnly" xml:space="preserve">
    <value>Only single dimensional arrays are supported for the requested action.</value>
  </data>
  <data name="ICollection_ArrayTypeInvalid" xml:space="preserve">
    <value>Target array type is not compatible with the type of items in the collection.</value>
  </data>
  <data name="Cache_KeyNotFound" xml:space="preserve">
    <value>The given key was not found in the cache.</value>
  </data>
  <data name="Cache_MinSize" xml:space="preserve">
    <value>Minimum cache size is 1.</value>
  </data>
  <data name="Cache_NullLoaderInvoke" xml:space="preserve">
    <value>Cache&lt;TKey, TValue&gt; was initialized without an item loader so elements must be added explicitly either by the Add method or by setting the indexer.</value>
  </data>
  <data name="Cache_StatisticsFormat" xml:space="preserve">
    <value>Cache&lt;{0}, {1}&gt; cache statistics:
Count: {2}
Capacity: {3}
Number of writes: {4}
Number of reads: {5}
Number of cache hits: {6}
Number of deletes: {7}
Hit rate: {8:P2}</value>
  </data>
  <data name="CastArray_BufferTooBigForCastLengthFormat" xml:space="preserve">
    <value>Length of buffer is too big to reinterpret it as type '{0}'.</value>
  </data>
  <data name="CastArray_SliceWrongStartIndexFormat" xml:space="preserve">
    <value>When the underlying type is '{1}' and the cast type is '{2}', '{0}' cannot be used as a start index for slicing because it cannot be aligned with an element in the underlying array. You can try to use the AsSpan property and the MemoryMarshal.Cast method if spans and misaligned memory access are supported on the current platform.</value>
  </data>
  <data name="Reflection_PropertyNotFoundTypeDescriptorFormat" xml:space="preserve">
    <value>Property "{0}" not found and cannot be set via TypeDescriptor on type "{1}".</value>
  </data>
  <data name="Reflection_CannotSetStaticPropertyTypeDescriptor" xml:space="preserve">
    <value>A static property cannot be set via TypeDescriptor.</value>
  </data>
  <data name="Reflection_CannotTreatPropertySetter" xml:space="preserve">
    <value>Cannot treat method as a property setter.</value>
  </data>
  <data name="CircularList_CapacityTooSmall" xml:space="preserve">
    <value>Capacity cannot be less than number of stored elements.</value>
  </data>
  <data name="IList_ComparerFail" xml:space="preserve">
    <value>Failed to compare two elements in the collection.</value>
  </data>
  <data name="IList_InconsistentComparer" xml:space="preserve">
    <value>The comparer returned inconsistent results.</value>
  </data>
  <data name="ICollection_CopyToDestArrayShort" xml:space="preserve">
    <value>Destination array is not long enough to copy all the items in the collection. Check array index and length.</value>
  </data>
  <data name="IDictionary_DuplicateKey" xml:space="preserve">
    <value>An item with the same key has already been added.</value>
  </data>
  <data name="Reflection_EmptyIndices" xml:space="preserve">
    <value>Indexer parameters are empty.</value>
  </data>
  <data name="IEnumerator_CollectionModified" xml:space="preserve">
    <value>Collection was modified; enumeration operation may not execute.</value>
  </data>
  <data name="IEnumerator_EnumerationNotStartedOrFinished" xml:space="preserve">
    <value>Enumeration has either not started or has already finished.</value>
  </data>
  <data name="Reflection_IndexerNotFoundFormat" xml:space="preserve">
    <value>No suitable indexer found on type "{0}" for the passed parameters.</value>
  </data>
  <data name="Reflection_IndexParamsLengthMismatchFormat" xml:space="preserve">
    <value>Expected number of array index arguments: {0}.</value>
  </data>
  <data name="Reflection_IndexParamsTypeMismatch" xml:space="preserve">
    <value>Index parameters cannot be cast to integer values.</value>
  </data>
  <data name="CircularSortedList_InsertByIndexNotSupported" xml:space="preserve">
    <value>Adding an element by index is not supported.</value>
  </data>
  <data name="CircularSortedList_InvalidKeyValueTypeFormat" xml:space="preserve">
    <value>Type of value should be either {0} or DictionaryEntry.</value>
  </data>
  <data name="Reflection_InvalidMethodBase" xml:space="preserve">
    <value>MethodInfo or ConstructorInfo expected.</value>
  </data>
  <data name="Reflection_DeclaringTypeExpected" xml:space="preserve">
    <value>DeclaringType of the provided member should not be null.</value>
  </data>
  <data name="Reflection_SecuritySettingsConflict" xml:space="preserve">
    <value>This operation is not supported if the executing assembly specifies both the AllowPartiallyTrustedCallersAttribute and the SecurityRulesAttribute with SecurityRuleSet.Level2 (which is the default if not defined). You can try the following options:
- Use the SecurityRulesAttribute with SecurityRuleSet.Level1. This is the recommended solution.
- Grant SecurityPermission with the SecurityPermissionFlag.SkipVerification flag when creating the restricted AppDomain.
- Use the SecurityRulesAttribute with SkipVerificationInFullTrust = true. If used with SecurityRuleSet.Level2 this will not solve the problem from a partially trusted domain though.
- Remove the AllowPartiallyTrustedCallersAttribute. This will not allow partially trusted callers to use your assembly though.</value>
  </data>
  <data name="Reflection_IndexerGenericNotSupported" xml:space="preserve">
    <value>Generic access of indexers with more than one index parameters is not supported. Use the non-generic Get/Set methods to access such indexers.</value>
  </data>
  <data name="IList_InvalidOffsLen" xml:space="preserve">
    <value>Offset and length were out of bounds for the list or count is greater than the number of elements from index to the end of the source collection.</value>
  </data>
  <data name="Array_InvalidOffsLen" xml:space="preserve">
    <value>Offset and length were out of bounds for the array.</value>
  </data>
  <data name="Reflection_MethodGenericNotSupported" xml:space="preserve">
    <value>Generic access of methods with more than four parameters is not supported. Use the non-generic Invoke method to access such methods.</value>
  </data>
  <data name="Reflection_CtorGenericNotSupported" xml:space="preserve">
    <value>Generic access of constructors with more than four parameters. Use the non-generic CreateInstance method to access such constructors.</value>
  </data>
  <data name="Reflection_GenericMember" xml:space="preserve">
    <value>Type or member with open generic arguments cannot be reflected.</value>
  </data>
  <data name="Reflection_ValueTypeWithPointersGenericNetStandard20" xml:space="preserve">
    <value>Generic access of potentially mutating value type members with pointer parameters or pointer return value is not supported in the .NET Standard 2.0 version of this library. Use the non-generic access instead.</value>
  </data>
  <data name="ArraySection_Null" xml:space="preserve">
    <value>The underlying array is null.</value>
  </data>
  <data name="ArraySection_Empty" xml:space="preserve">
    <value>The array section has no elements.</value>
  </data>
  <data name="ArraySection_InsufficientCapacity" xml:space="preserve">
    <value>The specified buffer has insufficient capacity.</value>
  </data>
  <data name="IDictionary_NonGenericKeyTypeInvalidFormat" xml:space="preserve">
    <value>The key "{0}" is not of type "{1}" and cannot be used in this generic collection.</value>
  </data>
  <data name="ICollection_NonGenericValueTypeInvalidFormat" xml:space="preserve">
    <value>The value "{0}" is not of type "{1}" and cannot be used in this generic collection.</value>
  </data>
  <data name="IDictionary_KeyNotFound" xml:space="preserve">
    <value>The given key was not present in the dictionary.</value>
  </data>
  <data name="ICollection_ReadOnlyModifyNotSupported" xml:space="preserve">
    <value>Modifying a read-only collection is not supported.</value>
  </data>
  <data name="General_NotAnInstanceOfTypeFormat" xml:space="preserve">
    <value>Specified argument is expected to be an instance of type {0}.</value>
  </data>
  <data name="General_ElementNotAnInstanceOfTypeFormat" xml:space="preserve">
    <value>Element at index {0} is expected to be an instance of type {1}.</value>
  </data>
  <data name="ComponentModel_ReturnedTypeInvalidFormat" xml:space="preserve">
    <value>The returned value is not compatible with type {0}</value>
  </data>
  <data name="Reflection_NotATypeFormat" xml:space="preserve">
    <value>Value "{0}" cannot be resolved as a System.Type.</value>
  </data>
  <data name="Reflection_NotSupportedMemberTypeFormat" xml:space="preserve">
    <value>Member type {0} is not supported.</value>
  </data>
  <data name="Reflection_PropertyHasNoGetterFormat" xml:space="preserve">
    <value>Property has no getter accessor: {0}.{1}</value>
  </data>
  <data name="Reflection_PropertyHasNoSetterFormat" xml:space="preserve">
    <value>Property has no setter accessor: {0}.{1}</value>
  </data>
  <data name="Resources_NeutralResourceFileNotFoundResXFormat" xml:space="preserve">
    <value>Resource file not found: {0}</value>
  </data>
  <data name="Resources_NeutralResourceNotFoundCompiledFormat" xml:space="preserve">
    <value>Could not find any resources appropriate for the specified culture or the neutral culture. Make sure "{0}" was correctly embedded or linked into assembly "{1}" at compile time, or that all the satellite assemblies required are loadable and fully signed.</value>
  </data>
  <data name="Resources_NeutralResourceNotFoundHybridFormat" xml:space="preserve">
    <value>Could not find any resources appropriate for the specified culture or the neutral culture. Make sure "{0}" was correctly embedded or linked into assembly "{1}" at compile time, or that all the satellite assemblies required are loadable and fully signed, or that XML resource file exists: {2}</value>
  </data>
  <data name="StringExtensions_SeparatorNullOrEmpty" xml:space="preserve">
    <value>Separator is null or empty.</value>
  </data>
  <data name="Profiler_MeasureItemToStringFormat" xml:space="preserve">
    <value>[{0}]{1}: Average Time: {2}; Total Time: {4}; First Call: {3}; Number of Calls: {5:N0}</value>
  </data>
  <data name="Reflection_CannotSetConstantFieldFormat" xml:space="preserve">
    <value>The constant field cannot be set: {0}.{1}</value>
  </data>
  <data name="Reflection_SetIndexerTypeDescriptorNotSupported" xml:space="preserve">
    <value>An indexer cannot be set via TypeDescriptor.</value>
  </data>
  <data name="Reflection_GetPropertyTypeDescriptorNotSupported" xml:space="preserve">
    <value>Getting property via TypeDescriptor is not supported in this overload of GetProperty method.</value>
  </data>
  <data name="Reflection_SetPropertyTypeDescriptorNotSupported" xml:space="preserve">
    <value>Setting property via TypeDescriptor is not supported in this overload of SetProperty method.</value>
  </data>
  <data name="Serialization_RootTypeExpected" xml:space="preserve">
    <value>Simple runtime element types or generic type definitions are expected.</value>
  </data>
  <data name="Serialization_MissingFieldFormat" xml:space="preserve">
    <value>Type "{0}" cannot be deserialized because it has no field "{1}". Set IgnoreNonExistingFields to true to suppress this exception.</value>
  </data>
  <data name="Serialization_PointerArrayTypeNotSupportedFormat" xml:space="preserve">
    <value>Array of pointer type '{0}' is not supported.</value>
  </data>
  <data name="Serialization_NonNullResultExpectedFormat" xml:space="preserve">
    <value>The deserialized value was null, which cannot be cast to {0}.</value>
  </data>
  <data name="Serialization_UnexpectedResultFormat" xml:space="preserve">
    <value>The type of the result is expected to be {0} but it was {1}.</value>
  </data>
  <data name="Serialization_UnexpectedTypeSafeFormat" xml:space="preserve">
    <value>Unexpected type name in safe mode: {0}.</value>
  </data>
  <data name="StreamExtensions_StreamCannotRead" xml:space="preserve">
    <value>Source stream cannot be read.</value>
  </data>
  <data name="StreamExtensions_StreamCannotWrite" xml:space="preserve">
    <value>Destination stream cannot be written.</value>
  </data>
  <data name="Reflection_TypeOrCtorInfoExpected" xml:space="preserve">
    <value>Argument must be either Type or ConstructorInfo.</value>
  </data>
  <data name="Reflection_InstanceCtorExpected" xml:space="preserve">
    <value>A ConstructorInfo of an instance constructor is expected.</value>
  </data>
  <data name="Enum_TypeParameterInvalid" xml:space="preserve">
    <value>Type parameter is expected to be a System.Enum type.</value>
  </data>
  <data name="Enum_ValueCannotBeParsedAsEnumFormat" xml:space="preserve">
    <value>Value '{0}' cannot be parsed as enumeration type {1}.</value>
  </data>
  <data name="General_ValueContainsIllegalPathCharactersFormat" xml:space="preserve">
    <value>Value "{0}" contains illegal path characters.</value>
  </data>
  <data name="General_InvalidAsyncResultFormat" xml:space="preserve">
    <value>Either the IAsyncResult object did not come from the corresponding '{0}' method, or the End method was called multiple times with the same IAsyncResult.</value>
  </data>
  <data name="General_InternalErrorFormat" xml:space="preserve">
    <value>Internal Error: {0}</value>
  </data>
  <data name="General_UnmanagedTypeArgumentExpectedFormat" xml:space="preserve">
    <value>Type '{0}' cannot be used as a type argument of generic type '{1}', because it contains references.</value>
  </data>
  <data name="General_UnmanagedMethodTypeArgumentExpectedFormat" xml:space="preserve">
    <value>Type '{0}' cannot be the type argument of this method because it contains references.</value>
  </data>
  <data name="Reflection_CannotCreateGenericMethod" xml:space="preserve">
    <value>Could not create generic method. For details see inner exception.</value>
  </data>
  <data name="Reflection_CannotGetPropertyTypeDescriptorFormat" xml:space="preserve">
    <value>Property "{0}" not found and cannot be retrieved via TypeDescriptor on type "{1}".</value>
  </data>
  <data name="Reflection_CannotGetStaticPropertyTypeDescriptor" xml:space="preserve">
    <value>A static property cannot be retrieved via TypeDescriptor.</value>
  </data>
  <data name="Reflection_CtorNotFoundFormat" xml:space="preserve">
    <value>No suitable constructor found on type "{0}" for the given parameters.</value>
  </data>
  <data name="Reflection_GetFieldTypeDescriptorNotSupported" xml:space="preserve">
    <value>A field cannot be retrieved via TypeDescriptor.</value>
  </data>
  <data name="Reflection_GetIndexerTypeDescriptorNotSupported" xml:space="preserve">
    <value>An indexer cannot be retrieved via TypeDescriptor.</value>
  </data>
  <data name="Reflection_InstanceFieldDoesNotExistFormat" xml:space="preserve">
    <value>Instance field "{0}" not found on type "{1}".</value>
  </data>
  <data name="Reflection_InstanceIsNull" xml:space="preserve">
    <value>Instance is null for a non-static member.</value>
  </data>
  <data name="Reflection_InstanceMethodNotFoundFormat" xml:space="preserve">
    <value>No suitable instance method "{0}" found on type "{1}" for the given parameters.</value>
  </data>
  <data name="Reflection_InstancePropertyDoesNotExistFormat" xml:space="preserve">
    <value>No suitable instance property "{0}" found on type "{1}".</value>
  </data>
  <data name="ComponentModel_PropertyValueNotExistFormat" xml:space="preserve">
    <value>No value exists for property '{0}'.</value>
  </data>
  <data name="Reflection_InvokeMethodTypeDescriptorNotSupported" xml:space="preserve">
    <value>Invoking a method via TypeDescriptor is not supported.</value>
  </data>
  <data name="Reflection_InvokeCtorTypeDescriptorNotSupported" xml:space="preserve">
    <value>Invoking a constructor via TypeDescriptor is not supported in this overload of CreateInstance method.</value>
  </data>
  <data name="Reflection_SetFieldTypeDescriptorNotSupported" xml:space="preserve">
    <value>A field cannot be set via TypeDescriptor.</value>
  </data>
  <data name="Reflection_StaticFieldDoesNotExistFormat" xml:space="preserve">
    <value>Static field "{0}" not found on type "{1}".</value>
  </data>
  <data name="Reflection_StaticMethodNotFoundFormat" xml:space="preserve">
    <value>No suitable static method "{0}" found on type "{1}" for the given parameters.</value>
  </data>
  <data name="Reflection_StaticPropertyDoesNotExistFormat" xml:space="preserve">
    <value>No suitable static property "{0}" found on type "{1}".</value>
  </data>
  <data name="Reflection_ParamsLengthMismatchFormat" xml:space="preserve">
    <value>Expected number of parameters: {0}, but it was {1}.</value>
  </data>
  <data name="Reflection_IndexerParamsLengthMismatchFormat" xml:space="preserve">
    <value>Expected number of indexer parameters: {0}, but it was {1}.</value>
  </data>
  <data name="Reflection_TypeArgsLengthMismatchFormat" xml:space="preserve">
    <value>Expected number of generic parameters: {0}.</value>
  </data>
  <data name="Reflection_TypeParamsAreNull" xml:space="preserve">
    <value>The method to invoke is generic but no generic parameters were passed.</value>
  </data>
  <data name="Reflection_NotAMemberFormat" xml:space="preserve">
    <value>No MemberInfo can be returned from expression type "{0}".</value>
  </data>
  <data name="Reflection_NotAMethod" xml:space="preserve">
    <value>Expression is not a method call.</value>
  </data>
  <data name="BinarySerialization_CannotDeserializeObjectFormat" xml:space="preserve">
    <value>Cannot deserialize as a standalone object: {0}</value>
  </data>
  <data name="BinarySerialization_TypePlatformNotSupportedFormat" xml:space="preserve">
    <value>Cannot deserialize type on this platform: {0}</value>
  </data>
  <data name="BinarySerialization_IEnumerableExpectedFormat" xml:space="preserve">
    <value>An IEnumerable type expected but {0} found during deserialization.</value>
  </data>
  <data name="BinarySerialization_InvalidEnumBaseFormat" xml:space="preserve">
    <value>Invalid enum base type: {0}. Serialization stream corrupted?</value>
  </data>
  <data name="BinarySerialization_InvalidStreamData" xml:space="preserve">
    <value>Invalid stream data.</value>
  </data>
  <data name="BinarySerialization_MissingFieldFormat" xml:space="preserve">
    <value>Type "{0}" cannot be deserialized because it has no field "{1}". To call the deserialization constructor implement the ISerializable interface. Use IgnoreObjectChanges option to suppress this exception.</value>
  </data>
  <data name="BinarySerialization_MissingFieldBaseFormat" xml:space="preserve">
    <value>Type "{0}" cannot be deserialized because field "{1}" not found in type "{2}". Use IgnoreObjectChanges option to suppress this exception.</value>
  </data>
  <data name="BinarySerialization_MissingISerializableCtorFormat" xml:space="preserve">
    <value>Type "{0}" does not have a special constructor to deserialize it as ISerializable</value>
  </data>
  <data name="BinarySerialization_ObjectHierarchyChangedFormat" xml:space="preserve">
    <value>Type "{0}" cannot be deserialized because its type hierarchy has been changed since serialization. Use IgnoreObjectChanges option to suppress this exception.</value>
  </data>
  <data name="BinarySerialization_GenericMethodNotFoundFormat" xml:space="preserve">
    <value>Generic method with signature "{0}" was not found in type "{1}".</value>
  </data>
  <data name="BinarySerialization_NotSupportedFormat" xml:space="preserve">
    <value>Serialization of type {0} is not supported with following serialization options: {1}.
You can try to enable the RecursiveSerializationAsFallback flag, though the serialized data will possibly not be able to be deserialized using the SafeMode flag.</value>
  </data>
  <data name="BinarySerialization_SurrogateChangedObjectFormat" xml:space="preserve">
    <value>The serialization surrogate has changed the reference of the result object, which prevented resolving circular references to itself. Object type: {0}</value>
  </data>
  <data name="BinarySerialization_CannotDecodeCollectionTypeFormat" xml:space="preserve">
    <value>Could not decode collection type: {0}. Serialization stream corrupted?</value>
  </data>
  <data name="BinarySerialization_CannotDecodeDataTypeFormat" xml:space="preserve">
    <value>Could not decode data type: {0}. Serialization stream corrupted?</value>
  </data>
  <data name="BinarySerialization_ReadOnlyCollectionNotSupportedFormat" xml:space="preserve">
    <value>Creating read-only collection of type "{0}" is not supported. Serialization stream corrupted?</value>
  </data>
  <data name="Reflection_CannotLoadAssemblyFormat" xml:space="preserve">
    <value>Failed to load assembly by name: "{0}".</value>
  </data>
  <data name="Reflection_CannotResolveAssemblyFormat" xml:space="preserve">
    <value>Cannot resolve assembly: "{0}".</value>
  </data>
  <data name="Reflection_InvalidAssemblyNameFormat" xml:space="preserve">
    <value>Assembly name is invalid: "{0}".</value>
  </data>
  <data name="Reflection_RefPointerTypeNotSupportedNetStandard20Format" xml:space="preserve">
    <value>Ref pointer type '{0}' is not supported in the .NET Standard 2.0 version of this library. If possible, try to use the .NET Standard 2.1 version or any .NET Core/Framework versions instead.</value>
  </data>
  <data name="Reflection_PointerTypeMonoNotSupportedFormat" xml:space="preserve">
    <value>Reflecting pointer type '{0}' is not supported on the Mono platform.</value>
  </data>
  <data name="Reflection_SetReadOnlyFieldGenericNetStandard20Format" xml:space="preserve">
    <value>Setting read-only field '{0}' of type '{1}' is not supported by the generic methods of FieldAccessor in the .NET Standard 2.0 version of this library. Use the non-generic Set method instead.</value>
  </data>
  <data name="Reflection_RefReturnTypeNetStandard20Format" xml:space="preserve">
    <value>Ref return type '{0}' is not supported in the .NET Standard 2.0 version of this library. If possible, try to use the .NET Standard 2.1 version or any .NET Core/Framework versions instead.</value>
  </data>
  <data name="Reflection_StaticPropertyExpectedGenericFormat" xml:space="preserve">
    <value>This method can be used to access static properties but {0}.{1} is an instance property.</value>
  </data>
  <data name="Reflection_StaticFieldExpectedGenericFormat" xml:space="preserve">
    <value>This method can be used to access static fields but {0}.{1} is an instance field.</value>
  </data>
  <data name="Reflection_InstanceFieldExpectedGenericFormat" xml:space="preserve">
    <value>This method can be used to access instance fields but {0}.{1} is a static field.</value>
  </data>
  <data name="Reflection_CannotInvokeFieldGenericFormat" xml:space="preserve">
    <value>Cannot access {0}.{1} field with the provided type arguments and/or parameters.</value>
  </data>
  <data name="Reflection_InstancePropertyExpectedGenericFormat" xml:space="preserve">
    <value>This method can be used to access instance properties but {0}.{1} is a static property.</value>
  </data>
  <data name="Reflection_CannotInvokePropertyGenericFormat" xml:space="preserve">
    <value>Cannot access {0}.{1} property with the provided type arguments and/or parameters.</value>
  </data>
  <data name="Reflection_StaticMethodExpectedGenericFormat" xml:space="preserve">
    <value>This method can be used to access static methods but {0}.{1} is an instance method.</value>
  </data>
  <data name="Reflection_InstanceMethodExpectedGenericFormat" xml:space="preserve">
    <value>This method can be used to access instance methods but {0}.{1} is a static method.</value>
  </data>
  <data name="Reflection_CannotInvokeMethodGenericFormat" xml:space="preserve">
    <value>Cannot access {0}.{1} method with the provided type arguments and/or parameters.</value>
  </data>
  <data name="Reflection_CannotCreateInstanceGenericFormat" xml:space="preserve">
    <value>Cannot create an instance of type '{0}' with the provided type arguments and/or parameters.</value>
  </data>
  <data name="Reflection_CannotCreateInstanceOfTypeFormat" xml:space="preserve">
    <value>Cannot create an instance of type '{0}' because abstract classes, interfaces and open generic types cannot be instantiated.</value>
  </data>
  <data name="Reflection_NoDefaultCtorFormat" xml:space="preserve">
    <value>Type '{0}' does not have a parameterless constructor. Obtain the CreateInstanceAccessor by a ConstructorInfo instead.</value>
  </data>
  <data name="BinarySerialization_CannotResolveAssemblySafeFormat" xml:space="preserve">
    <value>Cannot resolve assembly in safe mode: "{0}".
You may try to preload the assembly before deserialization or to disable SafeMode if the serialization stream is from a trusted source.</value>
  </data>
  <data name="BinarySerialization_CannotResolveTypeFormat" xml:space="preserve">
    <value>Could not resolve type name "{0}".</value>
  </data>
  <data name="BinarySerialization_CannotResolveExpectedTypeSafeFormat" xml:space="preserve">
    <value>Unexpected type name "{0}".
In safe mode you should specify the expected types in the expectedCustomTypes parameter of the deserialization methods.</value>
  </data>
    <data name="BinarySerialization_ExpectedTypeOmittedAssemblyNameSafeFormat" xml:space="preserve">
    <value>Expected type name "{0}" must be unique in SafeMode if the serialization stream has omitted assembly names.</value>
  </data>
  <data name="BinarySerialization_CannotResolveTypeInAssemblyFormat" xml:space="preserve">
    <value>Could not resolve type "{0}" in assembly "{1}".</value>
  </data>
  <data name="BinarySerialization_CannotResolveTypeInAssemblySafeFormat" xml:space="preserve">
    <value>Could not resolve type "{0}" in assembly "{1}".
You may try to preload the assembly before deserialization or disable SafeMode if the serialization stream is from a trusted source.</value>
  </data>
  <data name="BinarySerialization_CannotResolveExpectedTypeInAssemblySafeFormat" xml:space="preserve">
    <value>Unexpected type "{0}" in assembly "{1}".
In safe mode you should specify the expected types in the expectedCustomTypes parameter of the deserialization methods.
If assembly has a partial name or its identity has changed since the serialization you can use the ForwardedTypesSerializationBinder if you set its SafeMode to true.</value>
  </data>
  <data name="BinarySerialization_CircularIObjectReference" xml:space="preserve">
    <value>Deserialization of an IObjectReference instance has an unresolvable circular reference to itself.</value>
  </data>
  <data name="BinarySerialization_CircularIObjectReferenceCollectionFormat" xml:space="preserve">
    <value>Deserialization of an IObjectReference instance has an unresolvable circular reference to itself as an element in a collection of type '{0}'. Either try to use the ForceRecursiveSerializationOfSupportedTypes option on serialization, or avoid serializing circular references in the container object.</value>
  </data>
  <data name="BinarySerialization_CircularBuilderReferenceCollectionFormat" xml:space="preserve">
    <value>Could not deserialize the collection of type '{0}' because it has a circular reference to itself as an element and the collection requires a proxy builder to populate.
Either try to use the ForceRecursiveSerializationOfSupportedTypes option on serialization, or avoid serializing circular references in the container collection.</value>
  </data>
  <data name="BinarySerialization_CollectionPlatformNotSupportedFormat" xml:space="preserve">
    <value>The stream contains a collection of type '{0}', which is not supported on this platform.</value>
  </data>
  <data name="BinarySerialization_ValueTypeContainsReferenceSafeFormat" xml:space="preserve">
    <value>Value type '{0}' cannot be deserialized from raw data in safe mode because it contains references. If the serialization stream is from a trusted source you may try to disable safe mode to attempt the deserialization with marshaling.</value>
  </data>
  <data name="BinarySerialization_DataLengthTooSmall" xml:space="preserve">
    <value>Data length is too small.</value>
  </data>
  <data name="BinarySerialization_SurrogateNotAllowedInSafeMode" xml:space="preserve">
    <value>In safe mode no serialization surrogate is allowed to be used.</value>
  </data>
  <data name="BinarySerialization_BinderNotAllowedInSafeMode" xml:space="preserve">
    <value>The specified serialization binder cannot be used in safe mode. Only ForwardedTypesSerializationBinder is allowed if its SafeMode property is set to true.</value>
  </data>
  <data name="Unsafe_SecuritySettingsConflict" xml:space="preserve">
    <value>This operation is not supported in a partially trusted domain with the current security settings. You can try the following options:
- Grant SecurityPermission with the SecurityPermissionFlag.SkipVerification flag when creating the restricted AppDomain.
- Create the AppDomain with unrestricted permission set.</value>
  </data>
  <data name="BinarySerialization_DeserializeUnexpectedId" xml:space="preserve">
    <value>Unexpected id on deserialization. Serialization stream corrupted?</value>
  </data>
  <data name="BinarySerialization_MissingFieldSurrogateFormat" xml:space="preserve">
    <value>Number of serializable fields in type "{0}" has been decreased since serialization so cannot deserialize type "{1}".</value>
  </data>
  <data name="General_Null" xml:space="preserve">
    <value>&lt;null&gt;</value>
  </data>
  <data name="BinarySerialization_ObjectHierarchyChangedSurrogateFormat" xml:space="preserve">
    <value>Object hierarchy has been changed since serialization of type "{0}".</value>
  </data>
  <data name="General_Undefined" xml:space="preserve">
    <value>&lt;undefined&gt;</value>
  </data>
  <data name="BinarySerialization_UnexpectedFieldTypeFormat" xml:space="preserve">
    <value>Fields might have been reordered since serialization. Cannot deserialize type "{0}" because cannot assign value "{1}" to field "{2}.{3}".</value>
  </data>
  <data name="BinarySerialization_CannotCreateUninitializedObjectFormat" xml:space="preserve">
    <value>The current domain has insufficient permissions to create an empty instance of type "{0}" without a default constructor.</value>
  </data>
  <data name="BinarySerialization_CannotCreateObjectSafeFormat" xml:space="preserve">
    <value>In safe mode it is not supported to deserialize type "{0}".</value>
  </data>
  <data name="BinarySerialization_CannotCreateSerializableObjectSafe" xml:space="preserve">
    <value>In safe mode it is not supported to deserialize type "{0}". If it's because it is not marked by the SerializableAttribute you can try to enable the AllowNonSerializableExpectedCustomTypes option.</value>
  </data>
  <data name="BinarySerialization_NotBinarySerializableFormat" xml:space="preserve">
    <value>Type '{0}' was serialized as an IBinarySerializable instance though it is not IBinarySerializable now.</value>
  </data>
  <data name="BinarySerialization_NotAValueTypeFormat" xml:space="preserve">
    <value>Type '{0}' was serialized as a raw value type, though it is not a value type now.</value>
  </data>
  <data name="BinarySerialization_NotAnEnumFormat" xml:space="preserve">
    <value>Type '{0}' was serialized as an enum type though it is not an enum now.</value>
  </data>
  <data name="BinarySerialization_UnexpectedSerializationInfoElementFormat" xml:space="preserve">
    <value>Unexpected element in serialization info: {0}. Maybe the instance was not serialized by NameInvariantSurrogateSelector.</value>
  </data>
  <data name="BinarySerialization_ValueTypeExpected" xml:space="preserve">
    <value>Specified type must be a value type.</value>
  </data>
  <data name="XmlSerialization_NotAnIXmlSerializableFormat" xml:space="preserve">
    <value>Type "{0}" does not implement IXmlSerializable.</value>
  </data>
  <data name="XmlSerialization_NoDefaultCtorFormat" xml:space="preserve">
    <value>Type "{0}" does not have a parameterless constructor so it can be (de-)serialized either as a root element by SerializeContent and DeserializeContent or as a public property/field value in a parent object if the member value is not null after creating the parent object.</value>
  </data>
  <data name="XmlSerialization_ArrayDimensionSizeMismatchFormat" xml:space="preserve">
    <value>Cannot restore array "{0}" because length of the {1}. dimension does not match.</value>
  </data>
  <data name="XmlSerialization_ArrayLowerBoundMismatchFormat" xml:space="preserve">
    <value>Cannot restore array "{0}" because lower bound of the {1}. dimension does not match.</value>
  </data>
  <data name="XmlSerialization_PropertyTypeMismatchFormat" xml:space="preserve">
    <value>Property value of "{0}.{1}" is expected to be a type of "{2}" but was "{3}".</value>
  </data>
  <data name="XmlSerialization_ArrayRankMismatchFormat" xml:space="preserve">
    <value>Cannot restore array "{0}" because rank does not match. Expected rank: "{1}".</value>
  </data>
  <data name="XmlSerialization_ArraySizeMismatchFormat" xml:space="preserve">
    <value>Cannot restore array "{0}" because size does not match. Expected length: "{1}".</value>
  </data>
  <data name="XmlSerialization_BinarySerializationFailedFormat" xml:space="preserve">
    <value>Binary serialization of type "{0}" failed with options "{1}": {2}</value>
  </data>
  <data name="XmlSerialization_CannotDeserializeReadOnlyCollectionFormat" xml:space="preserve">
    <value>Collection "{0}" is read-only so its content cannot be restored.</value>
  </data>
  <data name="XmlSerialization_CannotDetermineElementTypeFormat" xml:space="preserve">
    <value>Could not determine type of element in collection "{0}".</value>
  </data>
  <data name="XmlSerialization_CannotResolveTypeFormat" xml:space="preserve">
    <value>Could not resolve type: "{0}".</value>
  </data>
  <data name="XmlSerialization_CannotResolveTypeSafeFormat" xml:space="preserve">
    <value>Could not resolve type in safe mode: "{0}".
In safe mode you must specify every non-natively supported type that are expected to be present in the XML stream.</value>
  </data>
  <data name="XmlSerialization_SerializingTypeNotSupportedFormat" xml:space="preserve">
    <value>Serializing type "{0}" is not supported with following options: {1}. You may either use fallback options (e.g. RecursiveSerializationAsFallback) or provide a type converter for the type.</value>
  </data>
  <data name="XmlSerialization_CannotSerializeCollectionFormat" xml:space="preserve">
    <value>Cannot serialize collection "{0}" with following options: "{1}". You may either use fallback options (e.g. RecursiveSerializationAsFallback), provide a type converter or apply DesignerSerializationVisibilityAttribute with value Content on the container collection property or field.</value>
  </data>
  <data name="XmlSerialization_CannotSerializeUnsupportedComparerFormat" xml:space="preserve">
    <value>Cannot serialize known collection "{0}" with following options: "{1}" because it has an unsupported comparer.
You can force serialization by the RecursiveSerializationAsFallback option but then the comparer will be ignored and deserialization will use a default comparer.
You can also use the BinarySerializationAsFallback option, which serializes also the comparer but the deserialization might not work in safe mode.</value>
  </data>
  <data name="XmlSerialization_CannotSerializeUnsupportedCollectionFormat" xml:space="preserve">
    <value>Serialization of collection "{0}" is not supported with following options: "{1}", because it does not implement IList, IDictionary or ICollection&lt;T&gt; interfaces and has no initializer constructor that can accept an array or list.
To force the recursive serialization of the collection enable both RecursiveSerializationAsFallback and ForcedSerializationOfReadOnlyMembersAndCollections options; however, deserialization will likely fail in this case. Using BinarySerializationAsFallback option may also work.</value>
  </data>
  <data name="XmlSerialization_CrcError" xml:space="preserve">
    <value>Corrupt array data: Bad CRC.</value>
  </data>
  <data name="XmlSerialization_CrcHexExpectedFormat" xml:space="preserve">
    <value>The crc attribute should be a hex value but "{0}" found.</value>
  </data>
  <data name="XmlSerialization_DeserializingTypeNotSupportedFormat" xml:space="preserve">
    <value>Deserializing type "{0}" is not supported.</value>
  </data>
  <data name="XmlSerialization_HasNoMemberFormat" xml:space="preserve">
    <value>Type "{0}" has no public property or field "{1}".</value>
  </data>
  <data name="XmlSerialization_InconsistentArrayLengthFormat" xml:space="preserve">
    <value>Array items length mismatch. Expected items: {0}, found items: {1}.</value>
  </data>
  <data name="XmlSerialization_ItemExpectedFormat" xml:space="preserve">
    <value>Collection item expected but "{0}" found.</value>
  </data>
  <data name="XmlSerialization_InvalidArrayLengthFormat" xml:space="preserve">
    <value>Invalid array length: {0}</value>
  </data>
  <data name="XmlSerialization_InvalidArrayBoundsFormat" xml:space="preserve">
    <value>Invalid array bounds: {0}</value>
  </data>
  <data name="XmlSerialization_ArrayNoLength" xml:space="preserve">
    <value>Array length or dimensions are not specified.</value>
  </data>
  <data name="XmlSerialization_MixedArrayFormats" xml:space="preserve">
    <value>Mixed compact and non-compact array content found.</value>
  </data>
  <data name="XmlSerialization_NoContentFormat" xml:space="preserve">
    <value>Serialized content of type "{0}" not found.</value>
  </data>
  <data name="XmlSerialization_NotACollectionFormat" xml:space="preserve">
    <value>Type "{0}" is not a regular collection so items cannot be added to it.</value>
  </data>
  <data name="XmlSerialization_PropertyHasNoSetterFormat" xml:space="preserve">
    <value>Cannot restore property "{0}" in type "{1}" because it has no setter.</value>
  </data>
  <data name="XmlSerialization_PropertyHasNoSetterCantSetNullFormat" xml:space="preserve">
    <value>Cannot set null to non-null property "{0}" in type "{1}" because it has no setter.</value>
  </data>
  <data name="XmlSerialization_PropertyHasNoSetterGetsNullFormat" xml:space="preserve">
    <value>Cannot restore property "{0}" in type "{1}" because it has no setter and it returned null.</value>
  </data>
  <data name="XmlSerialization_RootObjectExpectedFormat" xml:space="preserve">
    <value>Root named "object" expected but "{0}" found.</value>
  </data>
  <data name="XmlSerialization_RootTypeMissing" xml:space="preserve">
    <value>Type of the root element is not specified.</value>
  </data>
  <data name="XmlSerialization_SerializingReadOnlyCollectionNotSupportedFormat" xml:space="preserve">
    <value>Content serialization of read-only collection type "{0}" is not supported because populating will not work at deserialization.
If the collection has an initializer constructor, then using XmlSerializer.Serialize method overloads instead of SerializeContent can work.</value>
  </data>
  <data name="XmlSerialization_SerializingNonPopulatableCollectionNotSupportedFormat" xml:space="preserve">
    <value>Content serialization of collection type "{0}" is not supported because it cannot be populated by standard interfaces.
If the collection has an initializer constructor, then using XmlSerializer.Serialize method overloads instead of SerializeContent can work.</value>
  </data>
  <data name="Resources_UnexpectedElementAtFormat" xml:space="preserve">
    <value>Unexpected element: "{0}" at line {1}, position {2}.</value>
  </data>
  <data name="XmlSerialization_UnexpectedElementFormat" xml:space="preserve">
    <value>Unexpected element: "{0}".</value>
  </data>
  <data name="XmlSerialization_CircularReferenceFormat" xml:space="preserve">
    <value>Circular reference found during serialization. Object is already serialized: "{0}". To avoid circular references use DesignerSerializationVisibilityAttribute with Hidden value on members directly or indirectly reference themselves.</value>
  </data>
  <data name="XmlSerialization_ValueTypeContainsReferenceSafeFormat" xml:space="preserve">
    <value>Value type "{0}" cannot be deserialized from raw data in safe mode because it contains references. If the XML data is from a trusted source you may try to use unsafe mode to attempt the deserialization with marshaling.</value>
  </data>
  <data name="XmlSerialization_InvalidComparerFormat" xml:space="preserve">
    <value>Invalid comparer for collection type "{0}": {1}</value>
  </data>
  <data name="XmlSerialization_InvalidEscapedContentFormat" xml:space="preserve">
    <value>Invalid escaped string content: "{0}".</value>
  </data>
  <data name="XmlSerialization_KeyValueMissingKey" xml:space="preserve">
    <value>Key element not found in key/value pair element.</value>
  </data>
  <data name="XmlSerialization_KeyValueMissingValue" xml:space="preserve">
    <value>Value element not found in key/value pair element.</value>
  </data>
  <data name="XmlSerialization_MultipleKeys" xml:space="preserve">
    <value>Multiple Key elements occurred in key-value element.</value>
  </data>
  <data name="XmlSerialization_MultipleValues" xml:space="preserve">
    <value>Multiple Value elements occurred in key-value element.</value>
  </data>
  <data name="XmlSerialization_UnexpectedEnd" xml:space="preserve">
    <value>Unexpected end of XML content.</value>
  </data>
  <data name="Profiler_Uncategorized" xml:space="preserve">
    <value>&lt;Uncategorized&gt;</value>
  </data>
  <data name="General_ObjectDisposed" xml:space="preserve">
    <value>Cannot access a disposed object.</value>
  </data>
  <data name="General_NotSupported" xml:space="preserve">
    <value>This operation is not supported.</value>
  </data>
  <data name="General_OperationCanceled" xml:space="preserve">
    <value>The operation was canceled.</value>
  </data>
  <data name="Resources_InvalidResXReaderPropertyChange" xml:space="preserve">
    <value>Property can be changed only before the enumeration.</value>
  </data>
  <data name="Resources_InvalidResXWriterPropertyChange" xml:space="preserve">
    <value>Property can be changed only before adding a row or generating any content.</value>
  </data>
  <data name="Resources_NoResXNameFormat" xml:space="preserve">
    <value>Cannot find a name for the resource at line {0}, position {1}.</value>
  </data>
  <data name="Resources_MissingAttributeFormat" xml:space="preserve">
    <value>"{0}" attribute is missing at line {1}, position {2}.</value>
  </data>
  <data name="Resources_HeaderMimeTypeNotSupportedFormat" xml:space="preserve">
    <value>Unsupported ResX header mime type "{0}" at line {1}, position {2}.</value>
  </data>
  <data name="Resources_MimeTypeNotSupportedFormat" xml:space="preserve">
    <value>Unsupported mime type "{0}" at line {1}, position {2}.</value>
  </data>
  <data name="Resources_BinaryFormatterNotSupportedFormat" xml:space="preserve">
    <value>When targeting .NET 8 or later, resources serialized by BinaryFormatter (mime type "{0}") are no longer supported. Line {1}, position {2}.</value>
  </data>
  <data name="Resources_BinaryFormatterSafeModeNotSupportedFormat" xml:space="preserve">
    <value>In safe mode it is not allowed to deserialize resource "{0}" because it was serialized by BinaryFormatter. Line {1}, position {2}.</value>
  </data>
  <data name="Resources_FileRefFileNotSupportedSafeModeFormat" xml:space="preserve">
    <value>In safe mode it is not supported to deserialize file references. Resource name: {0}.</value>
  </data>
  <data name="Resources_TypeResolverInSafeModeNotSupported" xml:space="preserve">
    <value>In safe mode it is not supported to resolve types by a type resolution service.</value>
  </data>
  <data name="Resources_ResXReaderNotSupportedFormat" xml:space="preserve">
    <value>Unsupported ResX reader "{0}" at line {1}, position {2}.</value>
  </data>
  <data name="Resources_ResXWriterNotSupportedFormat" xml:space="preserve">
    <value>Unsupported ResX writer "{0}" at line {1}, position {2}.</value>
  </data>
  <data name="Resources_TypeLoadExceptionAtFormat" xml:space="preserve">
    <value>Could not resolve type "{0}" in the data at line {1}, position {2}.</value>
  </data>
  <data name="Resources_TypeLoadExceptionSafeAtFormat" xml:space="preserve">
    <value>Could not resolve type in safe mode "{0}" in the data at line {1}, position {2}.
You may try to specify the expected type or use the unsafe GetValue if the resource is from a trusted source.</value>
  </data>
  <data name="Resources_TypeLoadExceptionFormat" xml:space="preserve">
    <value>Could not resolve type "{0}".</value>
  </data>
  <data name="Resources_TypeLoadExceptionSafeFormat" xml:space="preserve">
    <value>Could not resolve type in safe mode: "{0}".
You may try to specify the expected type or use the unsafe GetValue if the resource is from a trusted source.</value>
  </data>
  <data name="General_ArgumentEmpty" xml:space="preserve">
    <value>Value cannot be empty.</value>
  </data>
  <data name="General_ArgumentInvalid" xml:space="preserve">
    <value>The specified argument is invalid.</value>
  </data>
  <data name="General_CollectionEmpty" xml:space="preserve">
    <value>The collection contains no elements.</value>
  </data>
  <data name="Reflection_TypeWithAssemblyName" xml:space="preserve">
    <value>In this ResolveType overload the type name should not contain the assembly name.</value>
  </data>
  <data name="Resources_NonStringResourceWithTypeFormat" xml:space="preserve">
    <value>Type of resource "{0}" is not string but "{1}" - enable SafeMode or use GetObject instead.</value>
  </data>
  <data name="Resources_NonStreamResourceWithTypeFormat" xml:space="preserve">
    <value>Type of resource "{0}" is not MemoryStream but "{1}" - enable SafeMode or use GetObject instead.</value>
  </data>
  <data name="Resources_ConvertFromStringNotSupportedAtFormat" xml:space="preserve">
    <value>Attempting to convert type "{0}" from string on line {1}, position {2} has failed: {3}</value>
  </data>
  <data name="Resources_ConvertFromStringNotSupportedFormat" xml:space="preserve">
    <value>Converting from string is not supported by {0}.</value>
  </data>
  <data name="Resources_ConvertFromByteArrayNotSupportedAtFormat" xml:space="preserve">
    <value>Attempting to convert type "{0}" from byte array on line {1}, position {2} has failed: {3}</value>
  </data>
  <data name="Resources_ConvertFromByteArrayNotSupportedFormat" xml:space="preserve">
    <value>Converting from byte array is not supported by {0}.</value>
  </data>
  <data name="Resources_WriterSaved" xml:space="preserve">
    <value>Resource writer has already been saved. You may not edit it.</value>
  </data>
  <data name="Resources_FileRefFileNotFoundFormat" xml:space="preserve">
    <value>File in ResX file reference cannot be found: {0}. Is base path set correctly?</value>
  </data>
  <data name="Resources_CompatibleFormatNotSupportedFormat" xml:space="preserve">
    <value>Saving a resource of type "{0}" is not supported in compatible format because BinaryFormatter is not supported in .NET 8 and above. Either apply the TypeConverterAttribute for type "{0}" that can convert to and from byte array or string, or disable compatible format.</value>
  </data>
  <data name="ByteArrayExtensions_SeparatorInvalidHex" xml:space="preserve">
    <value>The separator contains invalid characters. Hex digits are not allowed in separator.</value>
  </data>
  <data name="ByteArrayExtensions_SeparatorInvalidDec" xml:space="preserve">
    <value>The separator is empty or contains invalid characters. Decimal digits are not allowed in separator.</value>
  </data>
  <data name="General_ArgumentInvalidString" xml:space="preserve">
    <value>Input string contains an invalid value.</value>
  </data>
  <data name="Resources_HybridResSourceBinary" xml:space="preserve">
    <value>This operation is invalid when Source is CompiledOnly.</value>
  </data>
  <data name="Resources_InvalidDrmPropertyChange" xml:space="preserve">
    <value>Setting this property is invalid when UseLanguageSettings is true.</value>
  </data>
  <data name="SpanExtensions_CannotParseAsTypeFormat" xml:space="preserve">
    <value>The specified span '{0}' cannot be parsed as type {1}.</value>
  </data>
  <data name="StringExtensions_CannotParseAsTypeFormat" xml:space="preserve">
    <value>The specified string '{0}' cannot be parsed as type {1}.</value>
  </data>
  <data name="StringExtensions_SourceLengthNotEven" xml:space="preserve">
    <value>Source must consist of even amount of hex digits.</value>
  </data>
  <data name="StringSegment_Null" xml:space="preserve">
    <value>The string segment represents a null string.</value>
  </data>
  <data name="ComponentModel_CannotGetPropertyFormat" xml:space="preserve">
    <value>Cannot get property '{0}'.</value>
  </data>
  <data name="ComponentModel_CannotSetPropertyFormat" xml:space="preserve">
    <value>Cannot set property '{0}'.</value>
  </data>
  <data name="ComponentModel_NotEditing" xml:space="preserve">
    <value>Object is not in editing state.</value>
  </data>
  <data name="ComponentModel_MissingPropertyReference" xml:space="preserve">
    <value>&lt;Missing property value&gt;</value>
  </data>
  <data name="ComponentModel_DoValidationNull" xml:space="preserve">
    <value>The DoValidation method returned null.</value>
  </data>
  <data name="ComponentModel_ObservableObjectHasNoDefaultCtorFormat" xml:space="preserve">
    <value>The type has no parameterless constructor and thus cannot be cloned: {0}</value>
  </data>
  <data name="ComponentModel_CannotCastCommandTargetFormat" xml:space="preserve">
    <value>Failed to cast the command target '{0}' to type {1}.</value>
  </data>
  <data name="ComponentModel_CannotCastCommandParamFormat" xml:space="preserve">
    <value>Failed to cast the command parameter '{0}' to type {1}.</value>
  </data>
  <data name="ObjectExtensions_CannotConvertToTypeFormat" xml:space="preserve">
    <value>The specified argument cannot be converted to type {0}.</value>
  </data>
  <data name="ComponentModel_EnabledMustBeBool" xml:space="preserve">
    <value>'Enabled' state must have a boolean value.</value>
  </data>
  <data name="ComponentModel_MissingStateFormat" xml:space="preserve">
    <value>The property binding command state does not contain the expected entry '{0}'.</value>
  </data>
  <data name="ComponentModel_CannotAddNewFastBindingListFormat" xml:space="preserve">
    <value>Cannot add new item to the binding list because type '{0}' cannot be constructed without parameters. Subscribe the AddingNew event or override the AddNewCore or OnAddingNew methods to create a new item to add.</value>
  </data>
  <data name="ComponentModel_InvalidPropertyFormat" xml:space="preserve">
    <value>Property '{0}' of descriptor type '{1}' does not belong to type '{2}'.</value>
  </data>
  <data name="ComponentModel_PropertyNotExistsFormat" xml:space="preserve">
    <value>No property descriptor found for property name '{0}' in type '{1}'.</value>
  </data>
  <data name="General_QuoteStart" xml:space="preserve">
    <value>'</value>
  </data>
  <data name="General_QuoteEnd" xml:space="preserve">
    <value>'</value>
  </data>
  <data name="General_EnumOutOfRangeWithValuesFormat" xml:space="preserve">
    <value>Enum instance of '{0}' type must be one of the following values: {1}.</value>
  </data>
  <data name="General_FlagsEnumOutOfRangeWithValuesFormat" xml:space="preserve">
    <value>Enum instance of '{0}' type must consist of the following flags: {1}.</value>
  </data>
  <data name="General_EnumOutOfRangeFormat" xml:space="preserve">
    <value>Enum instance of '{0}' type must be one of the defined values.</value>
  </data>
  <data name="General_FlagsEnumOutOfRangeFormat" xml:space="preserve">
    <value>Enum instance of '{0}' type must consist of the defined flags.</value>
  </data>
  <data name="ComponentModel_AddNewDisabled" xml:space="preserve">
    <value>Cannot add new item to the binding list because AllowNew is false.</value>
  </data>
  <data name="ComponentModel_RemoveDisabled" xml:space="preserve">
    <value>Cannot remove item from the binding list because AllowRemove is false.</value>
  </data>
  <data name="ComponentModel_ReentrancyNotAllowed" xml:space="preserve">
    <value>Cannot change ObservableBindingList during a CollectionChanged or ListChanged event.</value>
  </data>
  <data name="ComponentModel_CannotAddNewObservableBindingListFormat" xml:space="preserve">
    <value>Cannot add new item to the binding list because type '{0}' cannot be constructed without parameters.</value>
  </data>
  <data name="ComponentModel_MissingEventFormat" xml:space="preserve">
    <value>There is no event '{0}' in component '{1}'.</value>
  </data>
  <data name="ComponentModel_InvalidEventFormat" xml:space="preserve">
    <value>Event '{0}' does not have regular event handler delegate type or accessors.</value>
  </data>
  <data name="ComponentModel_InvalidCommandSource" xml:space="preserve">
    <value>Source must be an object instance for instance events and a Type for static events.</value>
  </data>
  <data name="ComponentModel_CannotAddDisposedBinding" xml:space="preserve">
    <value>Cannot add an already disposed binding to this collection.</value>
  </data>
</root>